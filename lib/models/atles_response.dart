class ATLESResponse {
  final String content;
  final String model;
  final double confidence;
  final int processingTime; // milliseconds
  final ResponseSource source;
  final Map<String, dynamic> metadata;
  final List<String> suggestions;
  final ResponseType type;

  ATLESResponse({
    required this.content,
    required this.model,
    required this.confidence,
    required this.processingTime,
    required this.source,
    this.metadata = const {},
    this.suggestions = const [],
    this.type = ResponseType.text,
  });

  // Check response quality
  bool get isHighQuality => confidence > 0.8;
  bool get isMediumQuality => confidence > 0.5;
  bool get isLowQuality => confidence <= 0.5;

  // Get quality indicator
  String get qualityIndicator {
    if (isHighQuality) return 'ðŸŸ¢';
    if (isMediumQuality) return 'ðŸŸ¡';
    return 'ðŸ”´';
  }

  // Get source indicator
  String get sourceIndicator {
    switch (source) {
      case ResponseSource.localMobile:
        return 'ðŸ“±';
      case ResponseSource.desktopATLES:
        return 'ðŸ’»';
      case ResponseSource.collaborative:
        return 'ðŸ¤';
      case ResponseSource.cached:
        return 'ðŸ’¾';
    }
  }

  // Get processing speed category
  String get speedCategory {
    if (processingTime < 500) return 'Fast';
    if (processingTime < 2000) return 'Normal';
    return 'Slow';
  }

  // Create copy with updated fields
  ATLESResponse copyWith({
    String? content,
    String? model,
    double? confidence,
    int? processingTime,
    ResponseSource? source,
    Map<String, dynamic>? metadata,
    List<String>? suggestions,
    ResponseType? type,
  }) {
    return ATLESResponse(
      content: content ?? this.content,
      model: model ?? this.model,
      confidence: confidence ?? this.confidence,
      processingTime: processingTime ?? this.processingTime,
      source: source ?? this.source,
      metadata: metadata ?? this.metadata,
      suggestions: suggestions ?? this.suggestions,
      type: type ?? this.type,
    );
  }

  // Convert to JSON
  Map<String, dynamic> toJson() {
    return {
      'content': content,
      'model': model,
      'confidence': confidence,
      'processing_time': processingTime,
      'source': source.name,
      'metadata': metadata,
      'suggestions': suggestions,
      'type': type.name,
    };
  }

  // Create from JSON
  factory ATLESResponse.fromJson(Map<String, dynamic> json) {
    return ATLESResponse(
      content: json['content'],
      model: json['model'],
      confidence: json['confidence'].toDouble(),
      processingTime: json['processing_time'],
      source: ResponseSource.values.firstWhere(
        (s) => s.name == json['source'],
        orElse: () => ResponseSource.localMobile,
      ),
      metadata: json['metadata'] ?? {},
      suggestions: List<String>.from(json['suggestions'] ?? []),
      type: ResponseType.values.firstWhere(
        (t) => t.name == json['type'],
        orElse: () => ResponseType.text,
      ),
    );
  }

  @override
  String toString() {
    return 'ATLESResponse(model: $model, source: $source, confidence: $confidence, time: ${processingTime}ms)';
  }
}

enum ResponseSource {
  localMobile,    // Generated on mobile device
  desktopATLES,   // Generated by desktop ATLES
  collaborative,  // Combination of mobile + desktop
  cached,         // Retrieved from cache
}

enum ResponseType {
  text,           // Regular text response
  voice,          // Voice response
  image,          // Image analysis response
  code,           // Code generation response
  error,          // Error response
  system,         // System message
}

// Response quality metrics
class ResponseMetrics {
  final double averageConfidence;
  final int averageProcessingTime;
  final Map<ResponseSource, int> sourceDistribution;
  final Map<String, int> modelUsage;
  final int totalResponses;

  ResponseMetrics({
    required this.averageConfidence,
    required this.averageProcessingTime,
    required this.sourceDistribution,
    required this.modelUsage,
    required this.totalResponses,
  });

  // Get most used source
  ResponseSource get primarySource {
    return sourceDistribution.entries
        .reduce((a, b) => a.value > b.value ? a : b)
        .key;
  }

  // Get most used model
  String get primaryModel {
    if (modelUsage.isEmpty) return 'unknown';
    return modelUsage.entries
        .reduce((a, b) => a.value > b.value ? a : b)
        .key;
  }

  // Calculate from list of responses
  factory ResponseMetrics.fromResponses(List<ATLESResponse> responses) {
    if (responses.isEmpty) {
      return ResponseMetrics(
        averageConfidence: 0.0,
        averageProcessingTime: 0,
        sourceDistribution: {},
        modelUsage: {},
        totalResponses: 0,
      );
    }

    final totalConfidence = responses
        .map((r) => r.confidence)
        .reduce((a, b) => a + b);
    
    final totalTime = responses
        .map((r) => r.processingTime)
        .reduce((a, b) => a + b);

    final sourceDistribution = <ResponseSource, int>{};
    final modelUsage = <String, int>{};

    for (final response in responses) {
      sourceDistribution[response.source] = 
          (sourceDistribution[response.source] ?? 0) + 1;
      
      modelUsage[response.model] = 
          (modelUsage[response.model] ?? 0) + 1;
    }

    return ResponseMetrics(
      averageConfidence: totalConfidence / responses.length,
      averageProcessingTime: totalTime ~/ responses.length,
      sourceDistribution: sourceDistribution,
      modelUsage: modelUsage,
      totalResponses: responses.length,
    );
  }

  // Convert to JSON
  Map<String, dynamic> toJson() {
    return {
      'average_confidence': averageConfidence,
      'average_processing_time': averageProcessingTime,
      'source_distribution': sourceDistribution.map(
        (key, value) => MapEntry(key.name, value),
      ),
      'model_usage': modelUsage,
      'total_responses': totalResponses,
    };
  }

  @override
  String toString() {
    return 'ResponseMetrics(responses: $totalResponses, avgConfidence: ${averageConfidence.toStringAsFixed(2)}, avgTime: ${averageProcessingTime}ms)';
  }
}
